## 122.买卖股票的最佳时机

个人感觉这道题目有点玄学，思考的时候明明不能确定第二天的股市走向，但是解题的时候却按照全知的视角来写代码

奇怪，真奇怪

实现代码如下：

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        for (int i = 1; i < prices.size(); i++) {
            result += max(prices[i] - prices[i - 1], 0);
        }
        return result;
    }
};
```

虽然我还没看到动态规划，但是看了代码随想录的题解，也算有了点了解，思路如下：

+ 定义状态：
dp[i][0] 表示第 i 天持有股票后的最多现金。
dp[i][1] 表示第 i 天不持有股票（持有现金）的最多现金。

+ 初始化状态：
dp[0][0] 初始化为 -prices[0]，表示第一天买入股票后剩余的现金。
dp[0][1] 初始化为 0，表示第一天不持有股票（没有进行任何操作）的现金。

+ 状态转移：
对于第 i 天持有股票的情况，有两种选择：要么保持前一天的持有状态，要么在前一天不持有股票的基础上买入当天的股票，即 dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i])。
对于第 i 天不持有股票的情况，也有两种选择：要么保持前一天的不持有状态，要么在前一天持有股票的基础上卖出当天的股票，即 dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i])。

+ 返回结果：
最后一天不持有股票的现金一定是最大利润，因此返回 dp[n - 1][1]。

动态规划的代码如下：

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // dp[i][1]第i天持有的最多现金
        // dp[i][0]第i天持有股票后的最多现金
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            // 第i天持股票所剩最多现金 = max(第i-1天持股票所剩现金, 第i-1天持现金-买第i天的股票)
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            // 第i天持有最多现金 = max(第i-1天持有的最多现金，第i-1天持有股票的最多现金+第i天卖出股票)
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return max(dp[n - 1][0], dp[n - 1][1]);
    }
};
```
