## 39. 组合总和

先定义用于存储结果的二维向量 result 和记录当前组合的一维向量 path

对候选数组 candidates 排序后，调用回溯函数 backtrace 开始搜索。回溯函数接收候选数组、起始位置、当前组合元素和、目标和作为参数，在递归过程中，当当前组合元素和大于目标和时停止递归；等于目标和时将当前组合加入结果集

通过 for 循环从起始位置开始遍历候选数组，将当前元素加入当前组合并更新和，由于元素可重复使用，下一次递归仍从当前位置开始，递归返回后进行回溯操作，移除当前元素以尝试其他组合，最终主函数返回存储所有满足条件组合的结果集

实现代码如下：

```c++
class Solution {
private:
    std::vector<std::vector<int>> result;
    std::vector<int> path;

    // 回溯函数
    void backtrace(const std::vector<int>& nums, int start, int sum, int target) {
        if (sum > target) {
            return;
        }
        if (sum == target) {
            result.push_back(path);
            return;
        }

        for (int i = start; i < nums.size(); ++i) {
            // 选择当前元素
            path.push_back(nums[i]);
            // 递归调用，由于元素可重复使用，下一次递归仍从 i 开始
            backtrace(nums, i, sum + nums[i], target);
            // 回溯操作，撤销选择
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        backtrace(candidates, 0, 0, target);
        return result;
    }
};
```

## 40.组合总和II

思路和上面一道很相似，唯一的区别就是每次递归时开始的元素从当前这个变成了下一个

除此之外，还有一个问题就是要考虑去重，给定重复元素再排序后，判断是否满足nums[i] == nums[i + 1]

实现代码如下：

```c++
class Solution {
private:
    std::vector<std::vector<int>> result;
    std::vector<int> path;

    // 回溯函数
    void backtrace(const std::vector<int>& nums, int start, int sum, int target) {
        if (sum > target) {
            return;
        }
        if (sum == target) {
            result.push_back(path);
            return;
        }

        for (int i = start; i < nums.size(); ++i) {
            // 跳过重复元素，避免产生重复组合
            if (i > start && nums[i] == nums[i - 1]) {
                continue;
            }
            // 选择当前元素
            path.push_back(nums[i]);
            backtrace(nums, i + 1, sum + nums[i], target);
            // 回溯操作，撤销选择
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        backtrace(candidates, 0, 0, target);
        return result;
    }
};
```

## 131.分割回文串

