## 1049.最后一块石头的重量II

这道题目的难点在于将其转化成为动态规划中的01背包问题，要注意二层for循环内部的判决条件是 j >= stones[i] ，不要遗漏了等于的情况

实现代码如下：

```c++
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        if (stones.size() == 1)  return stones[0];

        int sum = 0;
        vector<int> nums(15001, 0);
        for (int i = 0; i < stones.size(); i++) {
            sum += stones[i];
        }
        int target = sum / 2;
        
        // 转化成最大空间为sum一半的01背包问题
        for (int i = 0; i < stones.size(); i++) {
            for (int j = target; j >= stones[i]; j--) {
                nums[j] = max(nums[j], nums[j - stones[i]] + stones[i]);
            }
        }

        int result = (sum - 2 * nums[target]); 
        return result;
    }
};
```

## 494. 目标和 

此问题可以转化为一个 0 - 1 背包问题。设数组元素总和为 sum，添加 + 号的元素总和为 x，添加 - 号的元素总和为 y，那么有以下关系：
- x + y = sum
- x - y = target

通过求解这两个方程，能够得到 x = (target + sum) / 2。所以问题就变成了在数组 nums 里选取若干元素，让它们的和等于 x 的方案数量。


## 474.一和零  


