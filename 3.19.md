## 1049.最后一块石头的重量II

这道题目的难点在于将其转化成为动态规划中的01背包问题，要注意二层for循环内部的判决条件是 j >= stones[i] ，不要遗漏了等于的情况

实现代码如下：

```c++
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        if (stones.size() == 1)  return stones[0];

        int sum = 0;
        vector<int> nums(15001, 0);
        for (int i = 0; i < stones.size(); i++) {
            sum += stones[i];
        }
        int target = sum / 2;
        
        // 转化成最大空间为sum一半的01背包问题
        for (int i = 0; i < stones.size(); i++) {
            for (int j = target; j >= stones[i]; j--) {
                nums[j] = max(nums[j], nums[j - stones[i]] + stones[i]);
            }
        }

        int result = (sum - 2 * nums[target]); 
        return result;
    }
};
```

## 494. 目标和 


## 474.一和零  


