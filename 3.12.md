## 134.加油站

要判断能否绕环路行驶一周，需要从每个可能的起点开始尝试，看是否能完整地走完一圈

对于每个加油站 i，更新 totalGas 和 currentGas 的值

如果 currentGas 小于 0，说明从当前的 start 出发无法到达 i+1 加油站，将 start 更新为 i+1，并将 currentGas 重置为 0

遍历结束后，如果 totalGas 小于 0，返回 -1，表示无法绕环路行驶一周

实现代码如下：

```c++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int n = gas.size();
        int totalGas = 0;  // 总油量
        int currentGas = 0; // 当前油量
        int start = 0;  // 起始加油站编号

        for (int i = 0; i < n; i++) {
            totalGas += gas[i] - cost[i];
            currentGas += gas[i] - cost[i];
            // 如果当前油量小于 0，说明从 start 出发无法到达 i+1，更新 start 为 i+1
            if (currentGas < 0) {
                start = i + 1;
                currentGas = 0;
            }
        }
        // 如果总油量小于 0，说明无论从哪个加油站出发都无法绕环路行驶一周
        if (totalGas < 0) {
            return -1;
        }
        return start;
    }
};
```

## 135.分发糖果

+ 从前往后遍历：

    从第二个孩子开始，如果当前孩子的评分比前一个孩子高，那么当前孩子的糖果数为前一个孩子的糖果数加 1。这一步保证了如果右边孩子评分比左边高，右边孩子能获得更多糖果

+ 从后往前遍历：

    从倒数第二个孩子开始，如果当前孩子的评分比后一个孩子高，那么当前孩子的糖果数取当前值和后一个孩子糖果数加 1 中的较大值。这一步保证了如果左边孩子评分比右边高，左边孩子能获得更多糖果

实现代码如下：

```c++
class Solution {
public:
    int candy(vector<int>& ratings) {
        vector<int> candyVec(ratings.size(), 1);
        // 从前向后
        for (int i = 1; i < ratings.size(); i++) {
            if (ratings[i] > ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1;
        }
        // 从后向前
        for (int i = ratings.size() - 2; i >= 0; i--) {
            if (ratings[i] > ratings[i + 1] ) {
                candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1);
            }
        }
        // 统计结果
        int result = 0;
        for (int i = 0; i < candyVec.size(); i++) result += candyVec[i];
        return result;
    }
};
```

## 860.柠檬水找零


## 406.根据身高重建队列
